#!/usr/bin/env python3
"""
UP:         python ro_placement.py hola.xdc 32 18 --main_x 42 --main_y 49 --lfsr_x 37 --lfsr_y 49
RIGHT:      python ro_placement.py hola.xdc 32 18 --main_x    --main_y    --lfsr_x    --lfsr_y   
ALL_RIGHT:  python ro_placement.py hola.xdc 32 18 --main_x 65 --main_y 99 --lfsr_x 65 --lfsr_y 149
"""
from typing import Iterator
import argparse
from pathlib import Path
from datetime import datetime

def ro_lines(ro_idx: int, x: int, y: int, bel_offset_y: int, main_or_lfsr: str) -> Iterator[str]:
    """Yield six BEL/LOC pairs for one RO."""
    
    bels  = ["D6LUT", "C6LUT", "B6LUT", "A6LUT", "D6LUT", "C6LUT"]
    y_off = [0, 0, 0, 0, -1, -1] # These offsets are relative to the given Y coordinate for the slice

    for lut_idx, (bel, dy) in enumerate(zip(bels, y_off), 1):
        cell = f"{{GEN_ROS_{main_or_lfsr}[{ro_idx}].RO_inst/aux_i_inferred_i_{lut_idx}}}"
        slice_xy = f"SLICE_X{x}Y{y + dy}"
        yield (f"set_property BEL {bel} [get_cells {cell}]\n"
               f"set_property LOC {slice_xy} [get_cells {cell}]\n")

def main() -> None:
    ap = argparse.ArgumentParser(description="Generate XDC constraints for manual RO placement.")
    ap.add_argument("xdc", type=Path, help="Path to the XDC file to append constraints to.")
    ap.add_argument("n_ros_main", type=int, help="Number of main ring oscillators.")
    ap.add_argument("n_ros_lfsr", type=int, help="Number of LFSR ring oscillators.")
    
    # New arguments for customizable starting coordinates
    ap.add_argument("--main_x", type=int, default=37, help="Initial X-coordinate for main ROs.")
    ap.add_argument("--main_y", type=int, default=149, help="Initial Y-coordinate for main ROs.")
    ap.add_argument("--lfsr_x", type=int, default=37, help="Initial X-coordinate for LFSR ROs.")
    ap.add_argument("--lfsr_y", type=int, default=99, help="Initial Y-coordinate for LFSR ROs.")

    args = ap.parse_args()

    # Get initial coordinates from arguments
    main_start_x = args.main_x
    main_start_y = args.main_y
    lfsr_start_x = args.lfsr_x
    lfsr_start_y = args.lfsr_y

    with args.xdc.open("a") as f:
        f.write(f"\n# --- Generated by place_ros.py on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")

        # --- Main ROs Placement ---
        x_main, y_main = main_start_x, main_start_y
        for ro_idx in range(args.n_ros_main):
            f.write(f"\n# GEN_ROS_MAIN[{ro_idx}]\n")
            for line in ro_lines(ro_idx, x_main, y_main, 0, 'MAIN'):
                f.write(line)

            # Move to the next RO location (down 2 slices)
            y_main -= 2
            if y_main < (lfsr_start_y if 'LFSR' in locals() and lfsr_start_y < main_start_y else 50):
                x_main += 2 # Move two X columns right
                y_main = main_start_y # Reset Y to start of column

        # --- LFSR ROs Placement ---
        x_lfsr, y_lfsr = lfsr_start_x, lfsr_start_y
        for ro_idx in range(args.n_ros_lfsr):
            f.write(f"\n# GEN_ROS_LFSR[{ro_idx}]\n")
            for line in ro_lines(ro_idx, x_lfsr, y_lfsr, 0, 'LFSR'):
                f.write(line)

            # Move to the next RO location (down 2 slices)
            y_lfsr -= 2
            if y_lfsr < 50:
                x_lfsr += 2 # Move two X columns right
                y_lfsr = lfsr_start_y # Reset Y to start of column

    print("Done â€” constraints appended.")

if __name__ == "__main__":
    main()
